{
  "refactorItems": [
    {
      "id": "RI-001",
      "title": "Fix test fixture initial state in define-refactor-plan tests",
      "description": "`seedState` in `define-refactor-plan.test.ts` seeds `evaluation_report.status` as `\"created\"` instead of `\"pending\"`. The command under test is responsible for transitioning that status from `\"pending\"` to `\"created\"`, so tests never exercise the nominal starting condition and the `pending → created` transition is invisible to the test suite.",
      "rationale": "This is the highest-priority item because it is an outright test fixture bug: the happy-path test asserts the post-run value of `evaluation_report.status` (`\"created\"`) against a state that was already seeded as `\"created\"`, making the assertion vacuously true. Fixing this closes a real gap in test correctness with minimal effort. ---"
    },
    {
      "id": "RI-002",
      "title": "Document (or align) the prototype → refactor auto-transition in define-refactor-plan",
      "description": "`define-refactor-plan.ts` accepts `current_phase === \"prototype\"` and silently transitions state to `\"refactor\"` before proceeding, but US-001-AC01 says the command must reject if `current_phase !== \"refactor\"`. The behaviour and the spec are inconsistent, and there is no code comment explaining the design decision.",
      "rationale": "A one-line comment or a small PRD note costs almost nothing and prevents future contributors from reverting the auto-transition as a \"bug fix\". Resolving the spec ambiguity is a quick win that improves long-term confidence in the codebase without any logic change. ---"
    },
    {
      "id": "RI-003",
      "title": "Fix write-json.ts indentation to 2-space",
      "description": "`src/commands/write-json.ts` uses 4-space indentation throughout, while every other file in `src/` uses 2-space. The project has no enforced formatter, so the inconsistency is only visible on manual inspection or diff review.",
      "rationale": "Trivial effort (mechanical find-and-replace) that eliminates a persistent readability inconsistency. Addressed now while the file is already in scope for this iteration's testing work, avoiding further accumulation. ---"
    },
    {
      "id": "RI-004",
      "title": "Migrate test-plan imports from schemas/ to scaffold/schemas/",
      "description": "`create-test-plan.ts`, `approve-test-plan.ts`, and `execute-test-plan.ts` import from `../../schemas/test-plan` (the copy directory), while all other commands use `../../scaffold/schemas/tmpl_*` (the canonical template directory). The two files are currently identical, but there is no mechanism to detect or prevent drift.",
      "rationale": "Low effort, low risk migration that removes an implicit duplication contract. Once these imports point to the canonical location, the `schemas/test-plan.ts` copy becomes unused and can be removed, leaving a single source of truth. ---"
    },
    {
      "id": "RI-005",
      "title": "Apply DI injection pattern to approve-requirement.ts",
      "description": "`approve-requirement.ts` hardcodes `new Date().toISOString()` and the `$` shell template for `write-json` invocation. Unlike the newer approve commands (`approve-test-plan`, `approve-refactor-plan`), this command cannot have its `last_updated` output deterministically asserted in unit tests.",
      "rationale": "The DI pattern is now established as the project standard for approve commands. Back-porting it to `approve-requirement.ts` completes the consistency and closes a testability gap for the oldest approve command. Effort is medium (extract the `$` call into a helper, add `nowFn`, thread through tests), but the payoff is a fully deterministic unit test. ---"
    },
    {
      "id": "RI-006",
      "title": "Add CI sync-check for scaffold copies (schemas and skills)",
      "description": "Two pairs of directories must stay in sync with their canonical scaffold originals, but no automated check currently enforces this: - **Schemas:** `scaffold/schemas/tmpl_*.ts` (canonical) ↔ `schemas/*.ts` (working copies used by a subset of commands). - **Skills:** `scaffold/.agents/skills/` (canonical) ↔ `.agents/skills/` (working copies). The resolution approach is a **CI sync-check script** (not consolidation): a Makefile target or test that diffs each working copy against its scaffold original and fails the build if any content diverges. Both pairs are in scope for the same script.",
      "rationale": "The risk is currently low (copies are identical in both cases) but grows with every schema or skill change. A CI check installs a permanent safety net without requiring a migration of all import paths or consumer directories. Covering both pairs in the same script avoids introducing a third location for drift to hide. This is lower urgency than the correctness and consistency items above, but establishing the contract now prevents future hard-to-diagnose mismatches in both schemas and skill definitions."
    }
  ]
}
