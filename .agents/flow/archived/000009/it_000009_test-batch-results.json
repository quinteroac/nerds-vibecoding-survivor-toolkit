[
  {"testCaseId": "TC-US001-01", "status": "passed", "evidence": "cli.ts imports runExecuteAutomatedFix, dispatches on subcommand 'automated-fix'; unit test 'registers execute automated-fix command in CLI' in execute-automated-fix.test.ts", "notes": ""},
  {"testCaseId": "TC-US001-02", "status": "passed", "evidence": "execute-automated-fix.ts:206-208 builds it_{iteration}_ISSUES.json path; readFileFn loads from FLOW_REL_DIR", "notes": ""},
  {"testCaseId": "TC-US001-03", "status": "passed", "evidence": "Line 227: openIssues = issues.filter(issue => issue.status === 'open'); test 'logs informative message when zero open issues'", "notes": ""},
  {"testCaseId": "TC-US001-04", "status": "passed", "evidence": "Line 243: for (const issue of issuesToProcess) processes one at a time sequentially", "notes": ""},
  {"testCaseId": "TC-US001-05", "status": "passed", "evidence": "loadSkillFn(projectRoot, 'automated-fix'); buildPrompt with issue JSON; invokeAgentFn with prompt. Test 'reads current-iteration issues file' verifies skill and agent call", "notes": ""},
  {"testCaseId": "TC-US001-06", "status": "passed", "evidence": "Lines 309-322: exitCode===0 -> issue.status='fixed', writeIssuesFile, commitIssueUpdate. Test verifies commit message and status update", "notes": ""},
  {"testCaseId": "TC-US001-07", "status": "passed", "evidence": "Lines 339-343: retriesRemaining>0 -> issue.status='retry', continue. Test 'marks issue as retry when hypothesis is not confirmed and retries remain'", "notes": ""},
  {"testCaseId": "TC-US001-08", "status": "passed", "evidence": "Lines 347-357: retries exhausted -> issue.status='manual-fix', write, commit. Test 'marks issue as manual-fix and commits when retries are exhausted'", "notes": ""},
  {"testCaseId": "TC-US001-09", "status": "passed", "evidence": "Lines 266-279: isNetworkError -> manual-fix, commit, break (no retry consumption). Test 'marks issue as manual-fix and does not consume retries on network errors'", "notes": ""},
  {"testCaseId": "TC-US001-10", "status": "passed", "evidence": "Lines 313-318: !committed -> logFn Error, logFn Failed, failedCount++. Test 'continues to next issue and marks failed summary when git commit fails'", "notes": ""},
  {"testCaseId": "TC-US001-11", "status": "passed", "evidence": "read_lints: no errors on execute-automated-fix.ts, cli.ts; tsconfig strict mode; project uses bun for type checking", "notes": ""},
  {"testCaseId": "TC-US002-01", "status": "passed", "evidence": "cli.ts:371 parseAgentArg(args.slice(1)) extracts --agent; usage shows --agent <provider>", "notes": ""},
  {"testCaseId": "TC-US002-02", "status": "passed", "evidence": "parseAgentArg throws 'Missing required --agent <provider> argument.'; test 'CLI exits with code 1 when --agent is missing' expects exitCode 1 and stderr", "notes": ""},
  {"testCaseId": "TC-US002-03", "status": "passed", "evidence": "invokeAgentFn receives options.provider from opts; test 'invokes agent with the provider selected by --agent' verifies providersUsed", "notes": ""},
  {"testCaseId": "TC-US003-01", "status": "passed", "evidence": "parseOptionalIntegerFlag(postAgentArgs, '--iterations', 1); default undefined -> opts.iterations ?? 1. Test 'defaults --iterations to 1'", "notes": ""},
  {"testCaseId": "TC-US003-02", "status": "passed", "evidence": "parseOptionalIntegerFlag(postIterationsArgs, '--retry-on-fail', 0); default undefined -> opts.retryOnFail ?? 0", "notes": ""},
  {"testCaseId": "TC-US003-03", "status": "passed", "evidence": "exitCode!==0 and retriesRemaining>0 -> retry. Test 'marks issue as retry when hypothesis is not confirmed and retries remain'", "notes": ""},
  {"testCaseId": "TC-US003-04", "status": "passed", "evidence": "Test 'stops retrying after reaching max retries': invokeCount=3, status manual-fix after 3 failed attempts", "notes": ""},
  {"testCaseId": "TC-US003-05", "status": "passed", "evidence": "maxIssuesToProcess = opts.iterations ?? 1; issuesToProcess = openIssues.slice(0, maxIssuesToProcess). Test 'processes only the first N open issues'", "notes": ""},
  {"testCaseId": "TC-US004-01", "status": "passed", "evidence": "JSON.parse readFileFn; parseIssuesForProcessing. Same as TC-US001-02", "notes": ""},
  {"testCaseId": "TC-US004-02", "status": "passed", "evidence": "openIssues = issues.filter(issue => issue.status === 'open'). Same as TC-US001-03", "notes": ""},
  {"testCaseId": "TC-US004-03", "status": "passed", "evidence": "!existsFn(issuesPath) -> throw 'Issues file not found...'. Test 'throws clear error when current-iteration issues file is missing'", "notes": ""},
  {"testCaseId": "TC-US004-04", "status": "passed", "evidence": "JSON.parse catch -> throw 'invalid issues JSON'. Test 'throws deterministic validation error for malformed issues JSON'", "notes": ""},
  {"testCaseId": "TC-US004-05", "status": "passed", "evidence": "openIssues.length===0 -> logFn('No open issues to process. Exiting without changes.'), return. Test 'logs informative message when zero open issues'", "notes": ""},
  {"testCaseId": "TC-US004-06", "status": "passed", "evidence": "parseIssuesForProcessing: missingFields -> logFn Warning, continue. Test 'skips issues with missing required fields and continues processing'", "notes": ""},
  {"testCaseId": "TC-US005-01", "status": "passed", "evidence": "logFn(`${issue.id}: Fixed`) or logFn(`${issue.id}: Failed`). Test US-005 verifies statusLines format", "notes": ""},
  {"testCaseId": "TC-US005-02", "status": "passed", "evidence": "logFn(`Summary: Fixed=${fixedCount} Failed=${failedCount}`). Test expects 'Summary: Fixed=1 Failed=1'", "notes": ""},
  {"testCaseId": "TC-US005-03", "status": "passed", "evidence": "All output via logFn (console.log); terminal-verifiable. Test asserts logs array contains expected lines", "notes": ""}
]
